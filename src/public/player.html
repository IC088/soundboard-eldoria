<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wildlands Soundboard - Player View</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #2c1810 0%, #1a0f08 100%);
      color: #fff;
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    header {
      text-align: center;
      padding: 30px 0;
      background: rgba(255, 180, 50, 0.1);
      border-radius: 15px;
      margin-bottom: 30px;
      border: 2px solid rgba(255, 180, 50, 0.3);
    }

    h1 {
      color: #ffb432;
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(255, 180, 50, 0.5);
    }

    .subtitle {
      color: rgba(255, 255, 255, 0.7);
      font-size: 1.1em;
    }

    .status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
    }

    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #4caf50;
      box-shadow: 0 0 10px #4caf50;
      animation: pulse 2s infinite;
    }

    .status-indicator.disconnected {
      background: #f44336;
      box-shadow: 0 0 10px #f44336;
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Volume Panel Styles */
    .volume-panel {
      background: rgba(30, 30, 30, 0.95);
      border: 2px solid rgba(255, 180, 50, 0.5);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      backdrop-filter: blur(10px);
    }

    .volume-panel h3 {
      margin: 0 0 20px 0;
      color: #ffb432;
      text-align: center;
      font-size: 1.3em;
    }

    .volume-control {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(50, 50, 50, 0.5);
      border-radius: 8px;
      transition: all 0.3s;
    }

    .volume-control:hover {
      background: rgba(60, 60, 60, 0.6);
    }

    .volume-control.master-volume {
      background: rgba(255, 180, 50, 0.1);
      border: 1px solid rgba(255, 180, 50, 0.3);
    }

    .volume-control label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-weight: bold;
      color: #fff;
    }

    .volume-label {
      font-size: 1em;
    }

    .volume-value {
      color: #ffb432;
      font-size: 1.1em;
      min-width: 50px;
      text-align: right;
    }

    .volume-control input[type="range"] {
      width: 100%;
      height: 8px;
      border-radius: 5px;
      background: rgba(100, 100, 100, 0.5);
      outline: none;
      -webkit-appearance: none;
    }

    .volume-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #ffb432;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 180, 50, 0.5);
      transition: all 0.3s;
    }

    .volume-control input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: #ffb432;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(255, 180, 50, 0.5);
      transition: all 0.3s;
    }

    .volume-control input[type="range"]:hover::-webkit-slider-thumb {
      background: #ffc84d;
      box-shadow: 0 0 15px rgba(255, 180, 50, 0.8);
      transform: scale(1.1);
    }

    .volume-control input[type="range"]:hover::-moz-range-thumb {
      background: #ffc84d;
      box-shadow: 0 0 15px rgba(255, 180, 50, 0.8);
      transform: scale(1.1);
    }

    .volume-control small {
      display: block;
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.85em;
      margin-top: 5px;
    }

    .btn-secondary {
      width: 100%;
      margin-top: 10px;
      padding: 12px;
      background: rgba(100, 100, 100, 0.3);
      color: #fff;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1em;
    }

    .btn-secondary:hover {
      background: rgba(100, 100, 100, 0.5);
      border-color: #ffb432;
      transform: translateY(-2px);
    }

    /* Now Playing Section */
    .now-playing {
      background: rgba(30, 30, 30, 0.8);
      border: 2px solid rgba(255, 180, 50, 0.3);
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
    }

    .now-playing h3 {
      color: #ffb432;
      margin-bottom: 15px;
      font-size: 1.2em;
    }

    .track-item {
      background: rgba(50, 50, 50, 0.5);
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .track-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #4caf50;
      box-shadow: 0 0 10px #4caf50;
      animation: pulse 1.5s infinite;
    }

    .track-info {
      flex: 1;
    }

    .track-name {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .track-type {
      color: rgba(255, 255, 255, 0.6);
      font-size: 0.9em;
    }

    .dm-volume {
      color: #ffb432;
      font-size: 0.9em;
    }

    .nothing-playing {
      text-align: center;
      padding: 40px;
      color: rgba(255, 255, 255, 0.5);
    }

    .nothing-playing-icon {
      font-size: 3em;
      margin-bottom: 10px;
    }

    footer {
      text-align: center;
      margin-top: 40px;
      padding: 20px;
      color: rgba(255, 255, 255, 0.5);
      font-size: 0.9em;
    }

    /* Info tooltip */
    .info-tooltip {
      background: rgba(255, 180, 50, 0.1);
      border: 1px solid rgba(255, 180, 50, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin: 20px 0;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.95em;
      line-height: 1.5;
    }

    .info-tooltip strong {
      color: #ffb432;
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üéß Wildlands Soundboard</h1>
      <p class="subtitle">Player View</p>
      <div class="status">
        <div class="status-indicator" id="connection-status"></div>
        <span id="connection-text">Connecting...</span>
      </div>
    </header>

    <!-- Volume Controls -->
    <div id="player-volume-panel" class="volume-panel">
      <h3>üîä Your Volume Controls</h3>
      
      <div class="info-tooltip">
        <strong>üí° How it works:</strong> Your GM controls what plays and when. 
        You control how loud it is for you! Adjust the sliders below to your comfort level.
      </div>

      <!-- Master Volume -->
      <div class="volume-control master-volume">
        <label>
          <span class="volume-label">üéöÔ∏è Master Volume</span>
          <span class="volume-value" id="master-value">70%</span>
        </label>
        <input type="range" id="volume-master" min="0" max="100" value="70" step="1">
        <small>Controls all audio from your GM</small>
      </div>

      <!-- BGM Volume -->
      <div class="volume-control">
        <label>
          <span class="volume-label">üéµ Background Music</span>
          <span class="volume-value" id="bgm-value">100%</span>
        </label>
        <input type="range" id="volume-bgm" min="0" max="100" value="100" step="1">
        <small>Adjust music tracks independently</small>
      </div>

      <!-- Ambience Volume -->
      <div class="volume-control">
        <label>
          <span class="volume-label">üåä Ambience</span>
          <span class="volume-value" id="ambience-value">100%</span>
        </label>
        <input type="range" id="volume-ambience" min="0" max="100" value="100" step="1">
        <small>Adjust ambient sounds independently</small>
      </div>

      <!-- SFX Volume -->
      <div class="volume-control">
        <label>
          <span class="volume-label">‚ö° Sound Effects</span>
          <span class="volume-value" id="sfx-value">100%</span>
        </label>
        <input type="range" id="volume-sfx" min="0" max="100" value="100" step="1">
        <small>Adjust sound effects independently</small>
      </div>

      <button id="reset-volumes" class="btn-secondary">Reset All to Defaults</button>
    </div>

    <!-- Now Playing -->
    <div class="now-playing">
      <h3>üìª Now Playing</h3>
      <div id="now-playing-content">
        <div class="nothing-playing">
          <div class="nothing-playing-icon">üéµ</div>
          <p>Waiting for your GM to start audio...</p>
        </div>
      </div>
    </div>

    <footer>
      <p>üé≤ Wildlands Campaign Audio System</p>
      <p>Volume controls are saved to your browser</p>
    </footer>
  </div>

  <!-- Audio Elements -->
  <audio id="bgm-audio" loop></audio>
  <audio id="ambience-audio" loop></audio>

  <!-- Socket.IO -->
  <script src="/socket.io/socket.io.js"></script>

  <script>
    // PlayerVolumeControl class embedded
    class PlayerVolumeControl {
      constructor(socket) {
        this.socket = socket;
        
        // Player volume settings (stored locally)
        this.volumes = {
          master: 0.7,      // Master volume for all audio
          bgm: 1.0,         // BGM multiplier
          ambience: 1.0,    // Ambience multiplier
          sfx: 1.0          // SFX multiplier
        };
        
        // Audio elements
        this.audioElements = {
          bgm: null,
          ambience: null,
          sfx: new Map() // SFX are one-shot, so we track multiple
        };
        
        // Load saved preferences from localStorage
        this.loadPreferences();
        
        // Setup UI controls
        this.setupUI();
        
        // Setup socket listeners
        this.setupSocketListeners();
      }
      
      // Load player preferences from localStorage
      loadPreferences() {
        const saved = localStorage.getItem('soundboard_player_volumes');
        if (saved) {
          try {
            this.volumes = { ...this.volumes, ...JSON.parse(saved) };
          } catch (e) {
            console.error('Failed to load volume preferences:', e);
          }
        }
      }
      
      // Save player preferences to localStorage
      savePreferences() {
        localStorage.setItem('soundboard_player_volumes', JSON.stringify(this.volumes));
      }
      
      // Setup UI controls for volume
      setupUI() {
        // Set initial slider values from saved preferences
        document.getElementById('volume-master').value = this.volumes.master * 100;
        document.getElementById('volume-bgm').value = this.volumes.bgm * 100;
        document.getElementById('volume-ambience').value = this.volumes.ambience * 100;
        document.getElementById('volume-sfx').value = this.volumes.sfx * 100;
        
        this.updateVolumeDisplays();
        
        // Attach event listeners
        document.getElementById('volume-master').addEventListener('input', (e) => {
          this.setVolume('master', e.target.value / 100);
        });
        
        document.getElementById('volume-bgm').addEventListener('input', (e) => {
          this.setVolume('bgm', e.target.value / 100);
        });
        
        document.getElementById('volume-ambience').addEventListener('input', (e) => {
          this.setVolume('ambience', e.target.value / 100);
        });
        
        document.getElementById('volume-sfx').addEventListener('input', (e) => {
          this.setVolume('sfx', e.target.value / 100);
        });
        
        document.getElementById('reset-volumes').addEventListener('click', () => {
          this.resetVolumes();
        });
      }
      
      // Update volume display percentages
      updateVolumeDisplays() {
        document.getElementById('master-value').textContent = Math.round(this.volumes.master * 100) + '%';
        document.getElementById('bgm-value').textContent = Math.round(this.volumes.bgm * 100) + '%';
        document.getElementById('ambience-value').textContent = Math.round(this.volumes.ambience * 100) + '%';
        document.getElementById('sfx-value').textContent = Math.round(this.volumes.sfx * 100) + '%';
      }
      
      // Set volume for a specific channel
      setVolume(channel, value) {
        this.volumes[channel] = value;
        this.updateVolumeDisplays();
        this.savePreferences();
        
        // Apply to currently playing audio
        if (channel === 'master') {
          this.applyAllVolumes();
        } else {
          this.applyVolume(channel);
        }
        
        // Optional: Send to server for logging
        this.socket.emit(`player:volume:${channel}`, value);
      }
      
      // Reset all volumes to defaults
      resetVolumes() {
        this.volumes = {
          master: 0.7,
          bgm: 1.0,
          ambience: 1.0,
          sfx: 1.0
        };
        
        document.getElementById('volume-master').value = 70;
        document.getElementById('volume-bgm').value = 100;
        document.getElementById('volume-ambience').value = 100;
        document.getElementById('volume-sfx').value = 100;
        
        this.updateVolumeDisplays();
        this.savePreferences();
        this.applyAllVolumes();
      }
      
      // Calculate final volume for a channel
      calculateVolume(channel, dmVolume) {
        return this.volumes.master * this.volumes[channel] * dmVolume;
      }
      
      // Play audio with fallback for autoplay policy
      playAudioWithFallback(audio, label) {
        audio.play().catch(e => {
          console.error(`${label} play error:`, e);
          
          // If it's NotAllowedError, set up a listener for user interaction
          if (e.name === 'NotAllowedError') {
            console.log(`${label} blocked by autoplay policy. Waiting for user interaction...`);
            
            // Try on any user interaction
            const tryPlay = () => {
              audio.play()
                .then(() => {
                  console.log(`${label} started after user interaction`);
                  document.removeEventListener('click', tryPlay);
                  document.removeEventListener('keydown', tryPlay);
                  document.removeEventListener('touchstart', tryPlay);
                })
                .catch(err => console.log(`${label} still blocked after interaction:`, err));
            };
            
            document.addEventListener('click', tryPlay, { once: false });
            document.addEventListener('keydown', tryPlay, { once: false });
            document.addEventListener('touchstart', tryPlay, { once: false });
          }
        });
      }
      
      // Apply volume to a specific channel

      applyVolume(channel) {
        const audio = this.audioElements[channel];
        if (!audio) return;
        
        // Get the DM's volume from the audio element's dataset
        const dmVolume = parseFloat(audio.dataset.dmVolume || '1.0');
        audio.volume = this.calculateVolume(channel, dmVolume);
      }
      
      // Apply all volumes
      applyAllVolumes() {
        ['bgm', 'ambience'].forEach(channel => this.applyVolume(channel));
        
        // Apply to all active SFX
        this.audioElements.sfx.forEach(audio => {
          const dmVolume = parseFloat(audio.dataset.dmVolume || '1.0');
          audio.volume = this.calculateVolume('sfx', dmVolume);
        });
      }
      
      // Setup socket listeners
      setupSocketListeners() {
        // BGM events
        this.socket.on('bgm:play', (data) => {
          console.log('BGM Play event:', data);
          
          // Get or create audio element
          if (!this.audioElements.bgm) {
            this.audioElements.bgm = document.getElementById('bgm-audio');
          }
          
          if (this.audioElements.bgm && data.track) {
            // Handle both formats: string URL or object with url property
            const trackUrl = typeof data.track === 'string' ? data.track : data.track.url;
            
            if (!trackUrl) {
              console.error('No valid track URL in data:', data);
              return;
            }
            
            // Set the source
            this.audioElements.bgm.src = trackUrl;
            
            // Store GM volume
            const dmVolume = data.volume !== undefined ? data.volume : 0.5;
            this.audioElements.bgm.dataset.dmVolume = dmVolume;
            
            // Calculate and apply volume
            this.audioElements.bgm.volume = this.calculateVolume('bgm', dmVolume);
            
            // Set loop
            this.audioElements.bgm.loop = data.loop !== undefined ? data.loop : true;
            
            // Set current time if provided
            if (data.currentTime !== undefined) {
              this.audioElements.bgm.currentTime = data.currentTime;
            }
            
            // Play with proper error handling
            this.playAudioWithFallback(this.audioElements.bgm, 'BGM');
          }
        });
        
        this.socket.on('bgm:pause', () => {
          if (this.audioElements.bgm) {
            this.audioElements.bgm.pause();
          }
        });
        
        this.socket.on('bgm:stop', () => {
          if (this.audioElements.bgm) {
            this.audioElements.bgm.pause();
            this.audioElements.bgm.currentTime = 0;
            this.audioElements.bgm.src = '';
          }
        });
        
        this.socket.on('bgm:volume', (dmVolume) => {
          if (this.audioElements.bgm) {
            this.audioElements.bgm.dataset.dmVolume = dmVolume;
            this.audioElements.bgm.volume = this.calculateVolume('bgm', dmVolume);
          }
        });
        
        this.socket.on('bgm:seek', (time) => {
          if (this.audioElements.bgm) {
            this.audioElements.bgm.currentTime = time;
          }
        });
        
        // Ambience events
        this.socket.on('ambience:play', (data) => {
          console.log('Ambience Play event:', data);
          
          if (!this.audioElements.ambience) {
            this.audioElements.ambience = document.getElementById('ambience-audio');
          }
          
          if (this.audioElements.ambience && data.track) {
            // Handle both formats: string URL or object with url property
            const trackUrl = typeof data.track === 'string' ? data.track : data.track.url;
            
            if (!trackUrl) {
              console.error('No valid track URL in data:', data);
              return;
            }
            
            // Set the source
            this.audioElements.ambience.src = trackUrl;
            
            // Store GM volume
            const dmVolume = data.volume !== undefined ? data.volume : 0.3;
            this.audioElements.ambience.dataset.dmVolume = dmVolume;
            
            // Calculate and apply volume
            this.audioElements.ambience.volume = this.calculateVolume('ambience', dmVolume);
            
            // Set loop
            this.audioElements.ambience.loop = data.loop !== undefined ? data.loop : true;
            
            // Set current time if provided
            if (data.currentTime !== undefined) {
              this.audioElements.ambience.currentTime = data.currentTime;
            }
            
            // Play with proper error handling
            this.playAudioWithFallback(this.audioElements.ambience, 'Ambience');
          }
        });
        
        this.socket.on('ambience:pause', () => {
          if (this.audioElements.ambience) {
            this.audioElements.ambience.pause();
          }
        });
        
        this.socket.on('ambience:stop', () => {
          if (this.audioElements.ambience) {
            this.audioElements.ambience.pause();
            this.audioElements.ambience.currentTime = 0;
            this.audioElements.ambience.src = '';
          }
        });
        
        this.socket.on('ambience:volume', (dmVolume) => {
          if (this.audioElements.ambience) {
            this.audioElements.ambience.dataset.dmVolume = dmVolume;
            this.audioElements.ambience.volume = this.calculateVolume('ambience', dmVolume);
          }
        });
        
        // SFX events
        this.socket.on('sfx:play', (data) => {
          console.log('SFX Play event:', data);
          
          if (!data) {
            console.error('SFX data missing:', data);
            return;
          }
          
          // Handle both formats: string URL or object with url property
          const trackUrl = typeof data === 'string' ? data : (data.url || (typeof data.track === 'string' ? data.track : data.track?.url));
          
          if (!trackUrl) {
            console.error('SFX data missing url:', data);
            return;
          }
          
          // Create new audio element for this SFX
          const audio = new Audio(trackUrl);
          const dmVolume = data.volume !== undefined ? data.volume : 1.0;
          
          audio.dataset.dmVolume = dmVolume;
          audio.volume = this.calculateVolume('sfx', dmVolume);
          
          // Track it
          const id = Date.now() + Math.random();
          this.audioElements.sfx.set(id, audio);
          
          // Remove from tracking when done
          audio.addEventListener('ended', () => {
            this.audioElements.sfx.delete(id);
          });
          
          this.playAudioWithFallback(audio, 'SFX');
        });
        
        // Master stop
        this.socket.on('master:stop', () => {
          if (this.audioElements.bgm) {
            this.audioElements.bgm.pause();
            this.audioElements.bgm.currentTime = 0;
            this.audioElements.bgm.src = '';
          }
          if (this.audioElements.ambience) {
            this.audioElements.ambience.pause();
            this.audioElements.ambience.currentTime = 0;
            this.audioElements.ambience.src = '';
          }
          // Stop all SFX
          this.audioElements.sfx.forEach(audio => {
            audio.pause();
            audio.currentTime = 0;
          });
          this.audioElements.sfx.clear();
        });
        
        // State sync for new connections
        this.socket.on('state:sync', (state) => {
          console.log('State sync:', state);
          
          // Apply BGM state
          if (state.bgm && state.bgm.playing && state.bgm.track) {
            if (!this.audioElements.bgm) {
              this.audioElements.bgm = document.getElementById('bgm-audio');
            }
            if (this.audioElements.bgm) {
              // Handle both formats: string URL or object with url property
              const trackUrl = typeof state.bgm.track === 'string' ? state.bgm.track : state.bgm.track.url;
              
              if (!trackUrl) {
                console.error('No valid track URL in BGM state:', state.bgm.track);
                return;
              }
              
              this.audioElements.bgm.src = trackUrl;
              this.audioElements.bgm.dataset.dmVolume = state.bgm.volume;
              this.audioElements.bgm.volume = this.calculateVolume('bgm', state.bgm.volume);
              this.audioElements.bgm.loop = state.bgm.loop !== undefined ? state.bgm.loop : true;
              this.audioElements.bgm.currentTime = state.bgm.currentTime || 0;
              this.playAudioWithFallback(this.audioElements.bgm, 'BGM');
            }
          }
          
          // Apply Ambience state
          if (state.ambience && state.ambience.playing && state.ambience.track) {
            if (!this.audioElements.ambience) {
              this.audioElements.ambience = document.getElementById('ambience-audio');
            }
            if (this.audioElements.ambience) {
              // Handle both formats: string URL or object with url property
              const trackUrl = typeof state.ambience.track === 'string' ? state.ambience.track : state.ambience.track.url;
              
              if (!trackUrl) {
                console.error('No valid track URL in Ambience state:', state.ambience.track);
                return;
              }
              
              this.audioElements.ambience.src = trackUrl;
              this.audioElements.ambience.dataset.dmVolume = state.ambience.volume;
              this.audioElements.ambience.volume = this.calculateVolume('ambience', state.ambience.volume);
              this.audioElements.ambience.loop = state.ambience.loop !== undefined ? state.ambience.loop : true;
              this.audioElements.ambience.currentTime = state.ambience.currentTime || 0;
              this.playAudioWithFallback(this.audioElements.ambience, 'Ambience');
            }
          }
        });
      }
    }
  </script>

  <script>
    // Initialize Socket.IO connection
    const socket = io();
    let playerVolumeControl;

    // Track current playback
    const currentlyPlaying = {
      bgm: null,
      ambience: null
    };

    // Connection status
    socket.on('connect', () => {
      console.log('Connected to soundboard server');
      socket.emit('register', 'player');
      
      document.getElementById('connection-status').classList.remove('disconnected');
      document.getElementById('connection-text').textContent = 'Connected to GM';

      // Initialize player volume control
      playerVolumeControl = new PlayerVolumeControl(socket);
      
      // Update UI when volumes change
      setupVolumeListeners();
    });

    socket.on('disconnect', () => {
      console.log('Disconnected from soundboard server');
      document.getElementById('connection-status').classList.add('disconnected');
      document.getElementById('connection-text').textContent = 'Disconnected';
    });

    // Setup volume change listeners
    function setupVolumeListeners() {
      // Update now playing when tracks change
      socket.on('bgm:play', (data) => {
        console.log('BGM play received:', data);
        currentlyPlaying.bgm = data;
        updateNowPlaying();
      });
      
      socket.on('bgm:stop', () => {
        console.log('BGM stopped');
        currentlyPlaying.bgm = null;
        updateNowPlaying();
      });
      
      socket.on('bgm:pause', () => {
        console.log('BGM paused');
        if (currentlyPlaying.bgm) {
          currentlyPlaying.bgm.playing = false;
        }
        updateNowPlaying();
      });
      
      socket.on('ambience:play', (data) => {
        console.log('Ambience play received:', data);
        currentlyPlaying.ambience = data;
        updateNowPlaying();
      });
      
      socket.on('ambience:stop', () => {
        console.log('Ambience stopped');
        currentlyPlaying.ambience = null;
        updateNowPlaying();
      });
      
      socket.on('ambience:pause', () => {
        console.log('Ambience paused');
        if (currentlyPlaying.ambience) {
          currentlyPlaying.ambience.playing = false;
        }
        updateNowPlaying();
      });
      
      socket.on('master:stop', () => {
        console.log('Master stop');
        currentlyPlaying.bgm = null;
        currentlyPlaying.ambience = null;
        updateNowPlaying();
      });
      
      socket.on('state:sync', (state) => {
        console.log('State sync received:', state);
        currentlyPlaying.bgm = state.bgm && state.bgm.playing ? state.bgm : null;
        currentlyPlaying.ambience = state.ambience && state.ambience.playing ? state.ambience : null;
        updateNowPlaying();
      });
    }

    // Update Now Playing display
    function updateNowPlaying() {
      const container = document.getElementById('now-playing-content');
      
      const bgm = currentlyPlaying.bgm;
      const ambience = currentlyPlaying.ambience;
      
      console.log('Updating now playing - BGM:', bgm, 'Ambience:', ambience);
      
      if (!bgm && !ambience) {
        container.innerHTML = `
          <div class="nothing-playing">
            <div class="nothing-playing-icon">üéµ</div>
            <p>Waiting for your GM to start audio...</p>
          </div>
        `;
        return;
      }

      let html = '';

      if (bgm && bgm.track) {
        const trackName = bgm.track.name || bgm.track.filename || 'Unknown Track';
        const volume = bgm.volume !== undefined ? bgm.volume : 0.5;
        html += `
          <div class="track-item">
            <div class="track-indicator"></div>
            <div class="track-info">
              <div class="track-name">üéµ ${trackName}</div>
              <div class="track-type">Background Music</div>
              <div class="dm-volume">GM Volume: ${Math.round(volume * 100)}%</div>
            </div>
          </div>
        `;
      }

      if (ambience && ambience.track) {
        const trackName = ambience.track.name || ambience.track.filename || 'Unknown Track';
        const volume = ambience.volume !== undefined ? ambience.volume : 0.3;
        html += `
          <div class="track-item">
            <div class="track-indicator"></div>
            <div class="track-info">
              <div class="track-name">üåä ${trackName}</div>
              <div class="track-type">Ambience</div>
              <div class="dm-volume">GM Volume: ${Math.round(volume * 100)}%</div>
            </div>
          </div>
        `;
      }

      container.innerHTML = html;
    }

    // Listen for BGM changes (already handled in setupVolumeListeners)
    // Removed duplicate listeners
  </script>
</body>
</html>